var PRS$0 = (function(o,t){o["__proto__"]={"a":t};return o["a"]===t})({},{});var DP$0 = Object.defineProperty;var GOPD$0 = Object.getOwnPropertyDescriptor;var MIXIN$0 = function(t,s){for(var p in s){if(s.hasOwnProperty(p)){DP$0(t,p,GOPD$0(s,p));}}return t};var _ = require('underscore')
  , BLOCK_SIZE = require('./constants').BLOCK_SIZE
  , AudioNode = require('./AudioNode')
  , AudioBuffer = require('./AudioBuffer')
  , readOnlyAttr = require('./utils').readOnlyAttr


var ScriptProcessorNode = (function(super$0){"use strict";var SP$0 = Object.setPrototypeOf||function(o,p){if(PRS$0){o["__proto__"]=p;}else {DP$0(o,"__proto__",{"value":p,"configurable":true,"enumerable":false,"writable":true});}return o};var OC$0 = Object.create;if(!PRS$0)MIXIN$0(ScriptProcessorNode, super$0);var proto$0={};

  function ScriptProcessorNode(context, bufferSize, numberOfInputChannels, numberOfOutputChannels) {
    if (!_.contains([256, 512, 1024, 2048, 4096, 8192, 16384], bufferSize))
      throw new Error('invalid bufferSize')
    super$0.call(this, context, 1, 1, numberOfInputChannels, 'explicit', 'speakers')

    this.numberOfOutputChannels = numberOfOutputChannels
    readOnlyAttr(this, 'bufferSize', bufferSize)
  }if(super$0!==null)SP$0(ScriptProcessorNode,super$0);ScriptProcessorNode.prototype = OC$0(super$0!==null?super$0.prototype:null,{"constructor":{"value":ScriptProcessorNode,"configurable":true,"writable":true}, onaudioprocess: {"set": $onaudioprocess_set$0, "configurable":true,"enumerable":true}});DP$0(ScriptProcessorNode,"prototype",{"configurable":false,"enumerable":false,"writable":false});

  function $onaudioprocess_set$0(onaudioprocess) {

    var inputBuffer = new AudioBuffer(this.channelCount, 0, this.context.sampleRate)
      , outputBuffer = new AudioBuffer(this.numberOfOutputChannels, 0, this.context.sampleRate)

    this._tick = function() {
      AudioNode.prototype._tick.apply(this, arguments)

      // Pull some data and add it to `inputBuffer`
      inputBuffer = inputBuffer.concat(this._inputs[0]._tick())

      // When enough data in `inputBuffer`, we run `onaudioprocess`
      if (inputBuffer.length === this.bufferSize) {
        var audioProcEvent = this._processingEvent(inputBuffer)
        onaudioprocess(audioProcEvent)
        inputBuffer = new AudioBuffer(this.channelCount, 0, this.context.sampleRate)
        outputBuffer = outputBuffer.concat(audioProcEvent.outputBuffer)
      } else if (inputBuffer.length >= this.bufferSize) throw new Error('this shouldnt happen')

      // When data has been processed, we return it
      if (outputBuffer.length >= BLOCK_SIZE) {
        var returnedBuffer = outputBuffer.slice(0, BLOCK_SIZE)
        outputBuffer = outputBuffer.slice(BLOCK_SIZE)
        return returnedBuffer
      } else return new AudioBuffer(this.numberOfOutputChannels, BLOCK_SIZE, this.context.sampleRate)
    }
  }

  proto$0._processingEvent = function(inBuffer) {
    return new AudioProcessingEvent(
      this.context.currentTime,
      inBuffer,
      new AudioBuffer(this.numberOfOutputChannels, this.bufferSize, this.context.sampleRate)
    )
  };

  proto$0._tick = function() {
    super$0.prototype._tick.call(this, arguments)
    return new AudioBuffer(this.numberOfOutputChannels, BLOCK_SIZE, this.context.sampleRate)
  };

MIXIN$0(ScriptProcessorNode.prototype,proto$0);proto$0=void 0;return ScriptProcessorNode;})(AudioNode);


var AudioProcessingEvent = (function(){"use strict";

  function AudioProcessingEvent(playbackTime, inputBuffer, outputBuffer) {
    this.playbackTime = playbackTime
    this.inputBuffer = inputBuffer
    this.outputBuffer = outputBuffer
  }DP$0(AudioProcessingEvent,"prototype",{"configurable":false,"enumerable":false,"writable":false});

;return AudioProcessingEvent;})();

module.exports = ScriptProcessorNode

var _ = require('underscore')

var AudioBuffer = (function(){"use strict";var PRS$0 = (function(o,t){o["__proto__"]={"a":t};return o["a"]===t})({},{});var DP$0 = Object.defineProperty;var GOPD$0 = Object.getOwnPropertyDescriptor;var MIXIN$0 = function(t,s){for(var p in s){if(s.hasOwnProperty(p)){DP$0(t,p,GOPD$0(s,p));}}return t};var static$0={},proto$0={};

  function AudioBuffer(numberOfChannels, length, sampleRate) {
    var ch
    this._data = []
    // Just a hack to be able to create a partially initialized AudioBuffer
    if (arguments.length) {
      for (ch = 0; ch < numberOfChannels; ch++)
        this._data.push(new Float32Array(length))
      this._defineAttrs(numberOfChannels, length, sampleRate)
    }
  }DP$0(AudioBuffer,"prototype",{"configurable":false,"enumerable":false,"writable":false});

  proto$0.getChannelData = function(channel) {
    if (channel >= this.numberOfChannels) throw new Error('invalid channel')
    return this._data[channel]
  };

  proto$0.slice = function() {
    var sliceArgs = _.toArray(arguments)
    var array = this._data.map(function(chArray) {
        return chArray.subarray.apply(chArray, sliceArgs)
      })
    return AudioBuffer.fromArray(array, this.sampleRate)
  };

  proto$0.concat = function(other) {
    if (other.sampleRate !== this.sampleRate)
      throw new Error('the 2 AudioBuffers don\'t have the same sampleRate')
    if (other.numberOfChannels !== this.numberOfChannels)
      throw new Error('the 2 AudioBuffers don\'t have the same numberOfChannels')
    var newLength = other.length + this.length,
      newChArray, newArray = this._data.map(function(chArray, ch) {
        newChArray = new Float32Array(newLength)
        newChArray.set(chArray)
        newChArray.set(other._data[ch], chArray.length)
        return newChArray
      })
    return AudioBuffer.fromArray(newArray, this.sampleRate)
  };

  proto$0.set = function(other, offset) {
    if (other.sampleRate !== this.sampleRate)
      throw new Error('the 2 AudioBuffers don\'t have the same sampleRate')
    if (other.numberOfChannels !== this.numberOfChannels)
      throw new Error('the 2 AudioBuffers don\'t have the same numberOfChannels')
    this._data.forEach(function(chArray, ch) {
      chArray.set(other.getChannelData(ch), offset)
    })
  };

  proto$0._defineAttrs = function(numberOfChannels, length, sampleRate) {
    if (!(sampleRate > 0)) throw new Error('invalid sample rate : ' + sampleRate)
    Object.defineProperty(this, 'sampleRate', {
      value: sampleRate,
      writable: false
    })
    if (!(length >= 0)) throw new Error('invalid length : ' + length)
    Object.defineProperty(this, 'length', {
      value: length,
      writable: false
    })
    Object.defineProperty(this, 'duration', {
      value: length / sampleRate,
      writable: false
    })
    if (!(numberOfChannels > 0)) throw new Error('invalid numberOfChannels : ' + numberOfChannels)
    Object.defineProperty(this, 'numberOfChannels', {
      value: numberOfChannels,
      writable: false
    })
  };

  static$0.filledWithVal = function(val, numberOfChannels, length, sampleRate) {
    var audioBuffer = new AudioBuffer(numberOfChannels, length, sampleRate),
      chData, ch, i
    for (ch = 0; ch < numberOfChannels; ch++) {
      chData = audioBuffer._data[ch]
      for (i = 0; i < length; i++) chData[i] = val
    }
    return audioBuffer
  };

  static$0.fromArray = function(array, sampleRate) {
    var audioBuffer = new AudioBuffer()
    audioBuffer._defineAttrs(array.length, array[0].length, sampleRate)
    array.forEach(function(chArray) {
      if (!(chArray instanceof Float32Array))
        chArray = new Float32Array(chArray)
      audioBuffer._data.push(chArray)
    })
    return audioBuffer
  };

MIXIN$0(AudioBuffer,static$0);MIXIN$0(AudioBuffer.prototype,proto$0);static$0=proto$0=void 0;return AudioBuffer;})();

module.exports = AudioBuffer
